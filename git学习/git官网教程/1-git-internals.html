<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8">
    <title>Pro Git</title>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script>
    <link rel="stylesheet" type="text/css" href="theme/html/html.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
  </head>
  <body data-type="book">
    <div class="navbar">
      <h1>Pro Git</h1>
      <p></p>
    </div>
    




<section data-type="chapter" id="_git_internals">
<h1>Git 内部原理</h1>


<p>无论是从之前的章节直接跳到本章，还是读完了其余章节一直到这——你都将在本章见识到 Git 的内部工作原理和实现方式。
我们发现学习这部分内容对于理解 Git 的用途和强大至关重要。不过也有人认为这些内容对于初学者而言可能难以理解且过于复杂。
因此我们把这部分内容放在最后一章，在学习过程中可以先阅读这部分，也可以晚点阅读这部分，这取决于你自己。</p>

<p>无论如何，既然已经读到了这里，就让我们开始吧。
首先要弄明白一点，从根本上来讲 Git 是一个内容寻址（content-addressable）文件系统，并在此之上提供了一个版本控制系统的用户界面。
马上你就会学到这意味着什么。</p>

<p>早期的 Git（主要是 1.5 之前的版本）的用户界面要比现在复杂的多，因为它更侧重于作为一个文件系统，而不是一个打磨过的版本控制系统。
不时会有一些陈词滥调抱怨早期那个晦涩复杂的 Git 用户界面；不过最近几年来，它已经被改进到不输于任何其他版本控制系统地清晰易用了。</p>

<p>内容寻址文件系统层是一套相当酷的东西，所以在本章我们会先讲解这部分内容。随后我们会学习传输机制和版本库管理任务——你迟早会和它们打交道。</p>






<section data-type="sect1" id="_plumbing_porcelain">
<h1>底层命令和高层命令</h1>

<p>本书旨在讨论如何通过 <code>checkout</code>、<code>branch</code>、<code>remote</code> 等大约 30 个诸如此类动词形式的命令来玩转 Git。
然而，由于 Git 最初是一套面向版本控制系统的工具集，而不是一个完整的、用户友好的版本控制系统，所以它还包含了一部分用于完成底层工作的命令。
这些命令被设计成能以 UNIX 命令行的风格连接在一起，抑或藉由脚本调用，来完成工作。
这部分命令一般被称作“底层（plumbing）”命令，而那些更友好的命令则被称作“高层（porcelain）”命令。</p>

<p>本书前九章专注于探讨高层命令。
然而在本章，我们将主要面对底层命令。
因为，底层命令得以让你窥探 Git 内部的工作机制，也有助于说明 Git 是如何完成工作的，以及它为何如此运作。
多数底层命令并不面向最终用户：它们更适合作为新命令和自定义脚本的组成部分。</p>

<p>当在一个新目录或已有目录执行 <code>git  init</code> 时，Git 会创建一个 <code>.git</code> 目录。
这个目录包含了几乎所有 Git 存储和操作的对象。
如若想备份或复制一个版本库，只需把这个目录拷贝至另一处即可。
本章探讨的所有内容，均位于这个目录内。
该目录的结构如下所示：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> ls -F1
<code class="go">HEAD</code>
<code class="go">config*</code>
<code class="go">description</code>
<code class="go">hooks/</code>
<code class="go">info/</code>
<code class="go">objects/</code>
<code class="go">refs/</code></pre>

<p>该目录下可能还会包含其他文件，不过对于一个全新的 <code>git init</code> 版本库，这将是你看到的默认结构。
<code>description</code> 文件仅供 GitWeb 程序使用，我们无需关心。
<code>config</code> 文件包含项目特有的配置选项。
<code>info</code> 目录包含一个全局性排除（global exclude）文件<a data-type="indexterm" data-primary="excludes" id="id-kAc7TpuRux"></a>，用以放置那些不希望被记录在 .gitignore 文件中的忽略模式（ignored patterns）。
<code>hooks</code> 目录包含客户端或服务端的钩子脚本（hook scripts），在 <a data-type="xref" href="1-customizing-git.html#_git_hooks">Git 钩子</a> 中这部分话题已被详细探讨过。</p>

<p>剩下的四个条目很重要：<code>HEAD</code> 文件、（尚待创建的）<code>index</code> 文件，和 <code>objects</code> 目录、<code>refs</code> 目录。
这些条目是 Git 的核心组成部分。
<code>objects</code> 目录存储所有数据内容；<code>refs</code> 目录存储指向数据（分支）的提交对象的指针；<code>HEAD</code> 文件指示目前被检出的分支；<code>index</code> 文件保存暂存区信息。
我们将详细地逐一检视这四部分，以期理解 Git 是如何运转的。</p>
</section>













<section data-type="sect1" id="_objects">
<h1>Git 对象</h1>

<p>Git 是一个内容寻址文件系统。
看起来很酷，
但这是什么意思呢？
这意味着，Git 的核心部分是一个简单的键值对数据库（key-value data store）。
你可以向该数据库插入任意类型的内容，它会返回一个键值，通过该键值可以在任意时刻再次检索（retrieve）该内容。
可以通过底层命令 <code>hash-object</code> 来演示上述效果——该命令可将任意数据保存于 <code>.git</code> 目录，并返回相应的键值。
首先，我们需要初始化一个新的 Git 版本库，并确认 <code>objects</code> 目录为空：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git init <code class="nb">test</code>
<code class="go">Initialized empty Git repository in /tmp/test/.git/</code>
<code class="gp">$</code> <code class="nb">cd test</code>
<code class="gp">$</code><code class="nb"> </code>find .git/objects
<code class="go">.git/objects</code>
<code class="go">.git/objects/info</code>
<code class="go">.git/objects/pack</code>
<code class="gp">$</code> find .git/objects -type f</pre>

<p>可以看到 Git 对 <code>objects</code> 目录进行了初始化，并创建了 <code>pack</code> 和 <code>info</code> 子目录，但均为空。
接着，往 Git 数据库存入一些文本：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> <code class="nb">echo</code> <code class="s1">'test content'</code> <code class="p">|</code> git <code class="nb">hash</code>-object -w --stdin
<code class="go">d670460b4b4aece5915caf5c68d12f560a9fe3e4</code></pre>

<p><code>-w</code> 选项指示 <code>hash-object</code> 命令存储数据对象；若不指定此选项，则该命令仅返回对应的键值。
<code>--stdin</code> 选项则指示该命令从标准输入读取内容；若不指定此选项，则须在命令尾部给出待存储文件的路径。
该命令输出一个长度为 40 个字符的校验和。
这是一个 SHA-1 哈希值——一个将待存储的数据外加一个头部信息（header）一起做 SHA-1 校验运算而得的校验和。后文会简要讨论该头部信息。
现在我们可以查看 Git 是如何存储数据的：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> find .git/objects -type f
<code class="go">.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</code></pre>

<p>可以在 <code>objects</code> 目录下看到一个文件。
这就是开始时 Git 存储内容的方式——一个文件对应一条内容，以该内容加上特定头部信息一起的 SHA-1 校验和为文件命名。
校验和的前两个字符用于命名子目录，余下的 38 个字符则用作文件名。</p>

<p>可以通过 <code>cat-file</code> 命令从 Git 那里取回数据。
这个命令简直就是一把剖析 Git 对象的瑞士军刀。
为 <code>cat-file</code> 指定 <code>-p</code> 选项可指示该命令自动判断内容的类型，并为我们显示格式友好的内容：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4
<code class="go">test content</code></pre>

<p>至此，你已经掌握了如何向 Git 中存入内容，以及如何将它们取出。
我们同样可以将这些操作应用于文件中的内容。
例如，可以对一个文件进行简单的版本控制。
首先，创建一个新文件并将其内容存入数据库：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> <code class="nb">echo</code> <code class="s1">'version 1'</code> <code class="p">&amp;</code>gt<code class="p">;</code> test.txt
<code class="gp">$</code> git <code class="nb">hash</code>-object -w test.txt
<code class="go">83baae61804e65cc73a7201a7252750c76066a30</code></pre>

<p>接着，向文件里写入新内容，并再次将其存入数据库：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> <code class="nb">echo</code> <code class="s1">'version 2'</code> <code class="p">&amp;</code>gt<code class="p">;</code> test.txt
<code class="gp">$</code> git <code class="nb">hash</code>-object -w test.txt
<code class="go">1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</code></pre>

<p>数据库记录下了该文件的两个不同版本，当然之前我们存入的第一条内容也还在：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> find .git/objects -type f
<code class="go">.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a</code>
<code class="go">.git/objects/83/baae61804e65cc73a7201a7252750c76066a30</code>
<code class="go">.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</code></pre>

<p>现在可以把文件内容恢复到第一个版本：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 <code class="p">&amp;</code>gt<code class="p">;</code> test.txt
<code class="gp">$</code> cat test.txt
<code class="go">version 1</code></pre>

<p>或者第二个版本：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a <code class="p">&amp;</code>gt<code class="p">;</code> test.txt
<code class="gp">$</code> cat test.txt
<code class="go">version 2</code></pre>

<p>然而，记住文件的每一个版本所对应的 SHA-1 值并不现实；另一个问题是，在这个（简单的版本控制）系统中，文件名并没有被保存——我们仅保存了文件的内容。
上述类型的对象我们称之为数据对象（blob object）。
利用 <code>cat-file -t</code> 命令，可以让 Git 告诉我们其内部存储的任何对象类型，只要给定该对象的 SHA-1 值：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
<code class="go">blob</code></pre>








<section data-type="sect2" id="_tree_objects">
<h2>树对象</h2>

<p>接下来要探讨的对象类型是树对象（tree object），它能解决文件名保存的问题，也允许我们将多个文件组织到一起。
Git 以一种类似于 UNIX 文件系统的方式存储内容，但作了些许简化。
所有内容均以树对象和数据对象的形式存储，其中树对象对应了 UNIX 中的目录项，数据对象则大致上对应了 inodes 或文件内容。
一个树对象包含了一条或多条树对象记录（tree entry），每条记录含有一个指向数据对象或者子树对象的 SHA-1 指针，以及相应的模式、类型、文件名信息。
例如，某项目当前对应的最新树对象可能是这样的：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git cat-file -p master^<code class="o">{</code>tree<code class="o">}</code>
<code class="go">100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README</code>
<code class="go">100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile</code>
<code class="go">040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib</code></pre>

<p><code>master^{tree}</code> 语法表示 <code>master</code> 分支上最新的提交所指向的树对象。
请注意，<code>lib</code> 子目录（所对应的那条树对象记录）并不是一个数据对象，而是一个指针，其指向的是另一个树对象：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0
<code class="go">100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb</code></pre>

<p>从概念上讲，Git 内部存储的数据有点像这样：</p>

<figure id="id-m1IPiPfXig">
<img src="book/10-git-internals/images/data-model-1.png" alt="简化版的 Git 数据模型。">
<figcaption><span class="label">Figure 10-1. </span>简化版的 Git 数据模型。</figcaption>
</figure>

<p>你可以轻松创建自己的树对象。
通常，Git 根据某一时刻暂存区（即 index 区域，下同）所表示的状态创建并记录一个对应的树对象，如此重复便可依次记录（某个时间段内）一系列的树对象。
因此，为创建一个树对象，首先需要通过暂存一些文件来创建一个暂存区。
可以通过底层命令 <code>update-index</code> 为一个单独文件——我们的 test.txt 文件的首个版本——创建一个暂存区。
利用该命令，可以把 test.txt 文件的首个版本人为地加入一个新的暂存区。
必须为上述命令指定 <code>--add</code> 选项，因为此前该文件并不在暂存区中（我们甚至都还没来得及创建一个暂存区呢）；同样必需的还有 <code>--cacheinfo</code> 选项，因为将要添加的文件位于 Git 数据库中，而不是位于当前目录下。
同时，需要指定文件模式、SHA-1 与文件名：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git update-index --add --cacheinfo <code class="m">100644</code> <code class="se">\</code>
<code class="go">  83baae61804e65cc73a7201a7252750c76066a30 test.txt</code></pre>

<p>本例中，我们指定的文件模式为 <code>100644</code>，表明这是一个普通文件。
其他选择包括：<code>100755</code>，表示一个可执行文件；<code>120000</code>，表示一个符号链接。
这里的文件模式参考了常见的 UNIX 文件模式，但远没那么灵活——上述三种模式即是 Git 文件（即数据对象）的所有合法模式（当然，还有其他一些模式，但用于目录项和子模块）。</p>

<p>现在，可以通过 <code>write-tree</code> 命令将暂存区内容写入一个树对象。
此处无需指定 <code>-w</code> 选项——如果某个树对象此前并不存在的话，当调用 <code>write-tree</code> 命令时，它会根据当前暂存区状态自动创建一个新的树对象：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git write-tree
<code class="go">d8329fc1cc938780ffdd9f94e0d364e0ea74f579</code>
<code class="gp">$</code> git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579
<code class="go">100644 blob 83baae61804e65cc73a7201a7252750c76066a30      test.txt</code></pre>

<p>不妨验证一下它确实是一个树对象：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579
<code class="go">tree</code></pre>

<p>接着我们来创建一个新的树对象，它包括 test.txt 文件的第二个版本，以及一个新的文件：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> <code class="nb">echo</code> <code class="s1">'new file'</code> <code class="p">&amp;</code>gt<code class="p">;</code> new.txt
<code class="gp">$</code> git update-index test.txt
<code class="gp">$</code> git update-index --add new.txt</pre>

<p>暂存区现在包含了 test.txt 文件的新版本，和一个新文件：new.txt。
记录下这个目录树（将当前暂存区的状态记录为一个树对象），然后观察它的结构：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git write-tree
<code class="go">0155eb4229851634a0f03eb265b69f5a2d56f341</code>
<code class="gp">$</code> git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341
<code class="go">100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt</code>
<code class="go">100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt</code></pre>

<p>我们注意到，新的树对象包含两条文件记录，同时 test.txt 的 SHA-1 值（<code>1f7a7a</code>）是先前值的“第二版”。
只是为了好玩：你可以将第一个树对象加入第二个树对象，使其成为新的树对象的一个子目录。
通过调用 <code>read-tree</code> 命令，可以把树对象读入暂存区。
本例中，可以通过对 <code>read-tree</code> 指定 <code>--prefix</code> 选项，将一个已有的树对象作为子树读入暂存区：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git <code class="nb">read</code>-tree --prefix<code class="o">=</code>bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579
<code class="gp">$</code> git write-tree
<code class="go">3c4e9cd789d88d8d89c1073707c3585e41b0e614</code>
<code class="gp">$</code> git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614
<code class="go">040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579      bak</code>
<code class="go">100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt</code>
<code class="go">100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt</code></pre>

<p>如果基于这个新的树对象创建一个工作目录，你会发现工作目录的根目录包含两个文件以及一个名为 <code>bak</code> 的子目录，该子目录包含 test.txt 文件的第一个版本。
可以认为 Git 内部存储着的用于表示上述结构的数据是这样的：</p>

<figure id="id-R2ImI2fEiA">
<img src="book/10-git-internals/images/data-model-2.png" alt="当前 Git 的数据内容结构。">
<figcaption><span class="label">Figure 10-2. </span>当前 Git 的数据内容结构。</figcaption>
</figure>
</section>













<section data-type="sect2" id="_git_commit_objects">
<h2>提交对象</h2>

<p>现在有三个树对象，分别代表了我们想要跟踪的不同项目快照。然而问题依旧：若想重用这些快照，你必须记住所有三个 SHA-1 哈希值。
并且，你也完全不知道是谁保存了这些快照，在什么时刻保存的，以及为什么保存这些快照。
而以上这些，正是提交对象（commit object）能为你保存的基本信息。</p>

<p>可以通过调用 <code>commit-tree</code> 命令创建一个提交对象，为此需要指定一个树对象的 SHA-1 值，以及该提交的父提交对象（如果有的话）。
我们从之前创建的第一个树对象开始：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> <code class="nb">echo</code> <code class="s1">'first commit'</code> <code class="p">|</code> git commit-tree d8329f
<code class="go">fdf4fc3344e67ab068f836878b6c4951e3b15f3d</code></pre>

<p>现在可以通过 <code>cat-file</code> 命令查看这个新提交对象：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git cat-file -p fdf4fc3
<code class="go">tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579</code>
<code class="go">author Scott Chacon &amp;lt;schacon@gmail.com&amp;gt; 1243040974 -0700</code>
<code class="go">committer Scott Chacon &amp;lt;schacon@gmail.com&amp;gt; 1243040974 -0700</code>

<code class="go">first commit</code></pre>

<p>提交对象的格式很简单：它先指定一个顶层树对象，代表当前项目快照；然后是作者/提交者信息（依据你的 <code>user.name</code> 和 <code>user.email</code> 配置来设定，外加一个时间戳）；留空一行，最后是提交注释。</p>

<p>接着，我们将创建另两个提交对象，它们分别引用各自的上一个提交（作为其父提交对象）：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> <code class="nb">echo</code> <code class="s1">'second commit'</code> <code class="p">|</code> git commit-tree 0155eb -p fdf4fc3
<code class="go">cac0cab538b970a37ea1e769cbbde608743bc96d</code>
<code class="gp">$</code> <code class="nb">echo</code> <code class="s1">'third commit'</code>  <code class="p">|</code> git commit-tree 3c4e9c -p cac0cab
<code class="go">1a410efbd13591db07496601ebc7a059dd55cfe9</code></pre>

<p>这三个提交对象分别指向之前创建的三个树对象快照中的一个。
现在，如果对最后一个提交的 SHA-1 值运行 <code>git log</code> 命令，会出乎意料的发现，你已有一个货真价实的、可由 <code>git log</code> 查看的 Git 提交历史了：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git log --stat 1a410e
<code class="go">commit 1a410efbd13591db07496601ebc7a059dd55cfe9</code>
<code class="go">Author: Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;</code>
<code class="go">Date:   Fri May 22 18:15:24 2009 -0700</code>

<code class="go">	third commit</code>

<code class="go"> bak/test.txt | 1 +</code>
<code class="go"> 1 file changed, 1 insertion(+)</code>

<code class="go">commit cac0cab538b970a37ea1e769cbbde608743bc96d</code>
<code class="go">Author: Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;</code>
<code class="go">Date:   Fri May 22 18:14:29 2009 -0700</code>

<code class="go">	second commit</code>

<code class="go"> new.txt  | 1 +</code>
<code class="go"> test.txt | 2 +-</code>
<code class="go"> 2 files changed, 2 insertions(+), 1 deletion(-)</code>

<code class="go">commit fdf4fc3344e67ab068f836878b6c4951e3b15f3d</code>
<code class="go">Author: Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;</code>
<code class="go">Date:   Fri May 22 18:09:34 2009 -0700</code>

<code class="go">    first commit</code>

<code class="go"> test.txt | 1 +</code>
<code class="go"> 1 file changed, 1 insertion(+)</code></pre>

<p>太神奇了：
就在刚才，你没有借助任何上层命令，仅凭几个底层操作便完成了一个 Git 提交历史的创建。
这就是每次我们运行 <code>git add</code> 和 <code>git commit</code> 命令时， Git 所做的实质工作——将被改写的文件保存为数据对象，更新暂存区，记录树对象，最后创建一个指明了顶层树对象和父提交的提交对象。
这三种主要的 Git 对象——数据对象、树对象、提交对象——最初均以单独文件的形式保存在 <code>.git/objects</code> 目录下。
下面列出了目前示例目录内的所有对象，辅以各自所保存内容的注释：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> find .git/objects -type f
<code class="go">.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2</code>
<code class="go">.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3</code>
<code class="go">.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2</code>
<code class="go">.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3</code>
<code class="go">.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1</code>
<code class="go">.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2</code>
<code class="go">.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content'</code>
<code class="go">.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1</code>
<code class="go">.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt</code>
<code class="go">.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1</code></pre>

<p>如果跟踪所有的内部指针，将得到一个类似下面的对象关系图：</p>

<figure id="id-DjIPsGUxi9">
<img src="book/10-git-internals/images/data-model-3.png" alt="你的 Git 目录下的所有对象。">
<figcaption><span class="label">Figure 10-3. </span>你的 Git 目录下的所有对象。</figcaption>
</figure>
</section>













<section data-type="sect2" id="-dZtQcEin">
<h2>对象存储</h2>

<p>前文曾提及，在存储内容时，会有个头部信息一并被保存。
让我们略花些时间来看看 Git 是如何存储其对象的。
通过在 Ruby 脚本语言中交互式地演示，你将看到一个数据对象——本例中是字符串“what is up, doc?”——是如何被存储的。</p>

<p>可以通过 <code>irb</code> 命令启动 Ruby 的交互模式：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> irb
<code class="go">&amp;gt;&amp;gt; content = "what is up, doc?"</code>
<code class="go">=&amp;gt; "what is up, doc?"</code></pre>

<p>Git 以对象类型作为开头来构造一个头部信息，本例中是一个“blob”字符串。
接着 Git 会添加一个空格，随后是数据内容的长度，最后是一个空字节（null byte）：</p>

<pre data-type="programlisting" data-code-language="console"><code class="go">&amp;gt;&amp;gt; header = "blob #{content.length}\0"</code>
<code class="go">=&amp;gt; "blob 16\u0000"</code></pre>

<p>Git 会将上述头部信息和原始数据拼接起来，并计算出这条新内容的 SHA-1 校验和。
在 Ruby 中可以这样计算 SHA-1 值——先通过 <code>require</code> 命令导入 SHA-1 digest 库，然后对目标字符串调用 <code>Digest::SHA1.hexdigest()</code>：</p>

<pre data-type="programlisting" data-code-language="console"><code class="go">&amp;gt;&amp;gt; store = header + content</code>
<code class="go">=&amp;gt; "blob 16\u0000what is up, doc?"</code>
<code class="go">&amp;gt;&amp;gt; require 'digest/sha1'</code>
<code class="go">=&amp;gt; true</code>
<code class="go">&amp;gt;&amp;gt; sha1 = Digest::SHA1.hexdigest(store)</code>
<code class="go">=&amp;gt; "bd9dbf5aae1a3862dd1526723246b20206e5fc37"</code></pre>

<p>Git 会通过 zlib 压缩这条新内容。在 Ruby 中可以借助 zlib 库做到这一点。
先导入相应的库，然后对目标内容调用 <code>Zlib::Deflate.deflate()</code>：</p>

<pre data-type="programlisting" data-code-language="console"><code class="go">&amp;gt;&amp;gt; require 'zlib'</code>
<code class="go">=&amp;gt; true</code>
<code class="go">&amp;gt;&amp;gt; zlib_content = Zlib::Deflate.deflate(store)</code>
<code class="go">=&amp;gt; "x\x9CK\xCA\xC9OR04c(\xCFH,Q\xC8,V(-\xD0QH\xC9O\xB6\a\x00_\x1C\a\x9D"</code></pre>

<p>最后，需要将这条经由 zlib 压缩的内容写入磁盘上的某个对象。
要先确定待写入对象的路径（SHA-1 值的前两个字符作为子目录名称，后 38 个字符则作为子目录内文件的名称）。
如果该子目录不存在，可以通过 Ruby 中的 <code>FileUtils.mkdir_p()</code> 函数来创建它。
接着，通过 <code>File.open()</code> 打开这个文件。最后，对上一步中得到的文件句柄调用 <code>write()</code> 函数，以向目标文件写入之前那条 zlib 压缩过的内容：</p>

<pre data-type="programlisting" data-code-language="console"><code class="go">&amp;gt;&amp;gt; path = '.git/objects/' + sha1[0,2] + '/' + sha1[2,38]</code>
<code class="go">=&amp;gt; ".git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37"</code>
<code class="go">&amp;gt;&amp;gt; require 'fileutils'</code>
<code class="go">=&amp;gt; true</code>
<code class="go">&amp;gt;&amp;gt; FileUtils.mkdir_p(File.dirname(path))</code>
<code class="go">=&amp;gt; ".git/objects/bd"</code>
<code class="go">&amp;gt;&amp;gt; File.open(path, 'w') { |f| f.write zlib_content }</code>
<code class="go">=&amp;gt; 32</code></pre>

<p>就是这样——你已创建了一个有效的 Git 数据对象。
所有的 Git 对象均以这种方式存储，区别仅在于类型标识——另两种对象类型的头部信息以字符串“commit”或“tree”开头，而不是“blob”。
另外，虽然数据对象的内容几乎可以是任何东西，但提交对象和树对象的内容却有各自固定的格式。</p>
</section>





</section>













<section data-type="sect1" id="_git_refs">
<h1>Git 引用</h1>

<p>我们可以借助类似于 <code>git log 1a410e</code> 这样的命令来浏览完整的提交历史，但为了能遍历那段历史从而找到所有相关对象，你仍须记住 <code>1a410e</code> 是最后一个提交。
我们需要一个文件来保存 SHA-1 值，并给文件起一个简单的名字，然后用这个名字指针来替代原始的 SHA-1 值。</p>

<p>在 Git 里，这样的文件被称为“引用（references，或缩写为 refs）”；你可以在 <code>.git/refs</code> 目录下找到这类含有 SHA-1 值的文件。
在目前的项目中，这个目录没有包含任何文件，但它包含了一个简单的目录结构：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> find .git/refs
<code class="go">.git/refs</code>
<code class="go">.git/refs/heads</code>
<code class="go">.git/refs/tags</code>
<code class="gp">$</code> find .git/refs -type f</pre>

<p>若要创建一个新引用来帮助记忆最新提交所在的位置，从技术上讲我们只需简单地做如下操作：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> <code class="nb">echo</code> <code class="s2">"1a410efbd13591db07496601ebc7a059dd55cfe9"</code> <code class="p">&amp;</code>gt<code class="p">;</code> .git/refs/heads/master</pre>

<p>现在，你就可以在 Git 命令中使用这个刚创建的新引用来代替 SHA-1 值了：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git log --pretty<code class="o">=</code>oneline  master
<code class="go">1a410efbd13591db07496601ebc7a059dd55cfe9 third commit</code>
<code class="go">cac0cab538b970a37ea1e769cbbde608743bc96d second commit</code>
<code class="go">fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre>

<p>我们不提倡直接编辑引用文件。
如果想更新某个引用，Git 提供了一个更加安全的命令 <code>update-ref</code> 来完成此事：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9</pre>

<p>这基本就是 Git 分支的本质：一个指向某一系列提交之首的指针或引用。
若想在第二个提交上创建一个分支，可以这么做：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git update-ref refs/heads/test cac0ca</pre>

<p>这个分支将只包含从第二个提交开始往前追溯的记录：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git log --pretty<code class="o">=</code>oneline <code class="nb">test</code>
<code class="go">cac0cab538b970a37ea1e769cbbde608743bc96d second commit</code>
<code class="go">fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre>

<p>至此，我们的 Git 数据库从概念上看起来像这样：</p>

<figure id="id-p4I6SAIp">
<img src="book/10-git-internals/images/data-model-4.png" alt="包含分支引用的 Git 目录对象。">
<figcaption><span class="label">Figure 10-4. </span>包含分支引用的 Git 目录对象。</figcaption>
</figure>

<p>当运行类似于 <code>git branch (branchname)</code> 这样的命令时，Git 实际上会运行 <code>update-ref</code> 命令，取得当前所在分支最新提交对应的 SHA-1 值，并将其加入你想要创建的任何新引用中。</p>








<section data-type="sect2" id="_the_head">
<h2>HEAD 引用</h2>

<p>现在的问题是，当你执行 <code>git branch (branchname)</code> 时，Git 如何知道最新提交的 SHA-1 值呢？
答案是 HEAD 文件。</p>

<p>HEAD 文件是一个符号引用（symbolic reference），指向目前所在的分支。
所谓符号引用，意味着它并不像普通引用那样包含一个 SHA-1 值——它是一个指向其他引用的指针。
如果查看 HEAD 文件的内容，一般而言我们看到的类似这样：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> cat .git/HEAD
<code class="go">ref: refs/heads/master</code></pre>

<p>如果执行 <code>git checkout test</code>，Git 会像这样更新 HEAD 文件：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> cat .git/HEAD
<code class="go">ref: refs/heads/test</code></pre>

<p>当我们执行 <code>git commit</code> 时，该命令会创建一个提交对象，并用 HEAD 文件中那个引用所指向的 SHA-1 值设置其父提交字段。</p>

<p>你也可以手动编辑该文件，然而同样存在一个更安全的命令来完成此事：<code>symbolic-ref</code>。
可以借助此命令来查看 HEAD 引用对应的值：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git symbolic-ref HEAD
<code class="go">refs/heads/master</code></pre>

<p>同样可以设置 HEAD 引用的值：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git symbolic-ref HEAD refs/heads/test
<code class="gp">$</code> cat .git/HEAD
<code class="go">ref: refs/heads/test</code></pre>

<p>不能把符号引用设置为一个不符合引用格式的值：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git symbolic-ref HEAD <code class="nb">test</code>
<code class="go">fatal: Refusing to point HEAD outside of refs/</code></pre>
</section>













<section data-type="sect2" id="-Gwt3TQIo">
<h2>标签引用</h2>

<p>前文我们刚讨论过 Git 的三种主要对象类型，事实上还有第四种。
标签对象（tag object）非常类似于一个提交对象——它包含一个标签创建者信息、一个日期、一段注释信息，以及一个指针。
主要的区别在于，标签对象通常指向一个提交对象，而不是一个树对象。
它像是一个永不移动的分支引用——永远指向同一个提交对象，只不过给这个提交对象加上一个更友好的名字罢了。</p>

<p>正如 <a data-type="xref" href="1-git-basics.html#_git_basics_chapter">Git 基础</a> 中所讨论的那样，存在两种类型的标签：附注标签和轻量标签。
可以像这样创建一个轻量标签：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d</pre>

<p>这就是轻量标签的全部内容——一个固定的引用。
然而，一个附注标签则更复杂一些。
若要创建一个附注标签，Git 会创建一个标签对象，并记录一个引用来指向该标签对象，而不是直接指向提交对象。
可以通过创建一个附注标签来验证这个过程（<code>-a</code> 选项指定了要创建的是一个附注标签）：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m <code class="s1">'test tag'</code></pre>

<p>下面是上述过程所建标签对象的 SHA-1 值：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> cat .git/refs/tags/v1.1
<code class="go">9585191f37f7b0fb9444f35a9bf50de191beadc2</code></pre>

<p>现在对该 SHA-1 值运行 <code>cat-file</code> 命令：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git cat-file -p 9585191f37f7b0fb9444f35a9bf50de191beadc2
<code class="go">object 1a410efbd13591db07496601ebc7a059dd55cfe9</code>
<code class="go">type commit</code>
<code class="go">tag v1.1</code>
<code class="go">tagger Scott Chacon &amp;lt;schacon@gmail.com&amp;gt; Sat May 23 16:48:58 2009 -0700</code>

<code class="go">test tag</code></pre>

<p>我们注意到，object 条目指向我们打了标签的那个提交对象的 SHA-1 值。
另外要注意的是，标签对象并非必须指向某个提交对象；你可以对任意类型的 Git 对象打标签。
例如，在 Git 源码中，项目维护者将他们的 GPG 公钥添加为一个数据对象，然后对这个对象打了一个标签。
可以克隆一个 Git 版本库，然后通过执行下面的命令来在这个版本库中查看上述公钥：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git cat-file blob junio-gpg-pub</pre>

<p>Linux 内核版本库同样有一个不指向提交对象的标签对象——首个被创建的标签对象所指向的是最初被引入版本库的那份内核源码所对应的树对象。</p>
</section>













<section data-type="sect2" id="-n5tvuXIX">
<h2>远程引用</h2>

<p>我们将看到的第三种引用类型是远程引用（remote reference）。
如果你添加了一个远程版本库并对其执行过推送操作，Git 会记录下最近一次推送操作时每一个分支所对应的值，并保存在 <code>refs/remotes</code> 目录下。
例如，你可以添加一个叫做 <code>origin</code> 的远程版本库，然后把 <code>master</code> 分支推送上去：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git remote add origin git@github.com:schacon/simplegit-progit.git
<code class="gp">$</code> git push origin master
<code class="go">Counting objects: 11, done.</code>
<code class="go">Compressing objects: 100% (5/5), done.</code>
<code class="go">Writing objects: 100% (7/7), 716 bytes, done.</code>
<code class="go">Total 7 (delta 2), reused 4 (delta 1)</code>
<code class="go">To git@github.com:schacon/simplegit-progit.git</code>
<code class="go">  a11bef0..ca82a6d  master -&amp;gt; master</code></pre>

<p>此时，如果查看 <code>refs/remotes/origin/master</code> 文件，可以发现 <code>origin</code> 远程版本库的 <code>master</code> 分支所对应的 SHA-1 值，就是最近一次与服务器通信时本地 <code>master</code> 分支所对应的 SHA-1 值：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> cat .git/refs/remotes/origin/master
<code class="go">ca82a6dff817ec66f44342007202690a93763949</code></pre>

<p>远程引用和分支（位于 <code>refs/heads</code> 目录下的引用）之间最主要的区别在于，远程引用是只读的。
虽然可以 <code>git checkout</code> 到某个远程引用，但是 Git 并不会将 HEAD 引用指向该远程引用。因此，你永远不能通过 <code>commit</code> 命令来更新远程引用。
Git 将这些远程引用作为记录远程服务器上各分支最后已知位置状态的书签来管理。</p>
</section>





</section>













<section data-type="sect1" id="-QDtDfj">
<h1>包文件</h1>

<p>让我们重新回到示例 Git 版本库的对象数据库。
目前为止，可以看到有 11 个对象——4 个数据对象、3 个树对象、3 个提交对象和 1 个标签对象：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> find .git/objects -type f
<code class="go">.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2</code>
<code class="go">.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3</code>
<code class="go">.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2</code>
<code class="go">.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3</code>
<code class="go">.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1</code>
<code class="go">.git/objects/95/85191f37f7b0fb9444f35a9bf50de191beadc2 # tag</code>
<code class="go">.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2</code>
<code class="go">.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content'</code>
<code class="go">.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1</code>
<code class="go">.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt</code>
<code class="go">.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1</code></pre>

<p>Git 使用 zlib 压缩这些文件的内容，而且我们并没有存储太多东西，所以上文中的文件一共只占用了 925 字节。
接下来，我们会指引你添加一些大文件到版本库中，以此展示 Git 的一个很有趣的功能。
为了便于展示，我们要把之前在 Grit 库中用到过的 <code>repo.rb</code> 文件添加进来——这是一个大小约为 22K 的源代码文件：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> curl https://raw.githubusercontent.com/mojombo/grit/master/lib/grit/repo.rb <code class="p">&amp;</code>gt<code class="p">;</code> repo.rb
<code class="gp">$</code> git add repo.rb
<code class="gp">$</code> git commit -m <code class="s1">'added repo.rb'</code>
<code class="go">[master 484a592] added repo.rb</code>
<code class="go"> 3 files changed, 709 insertions(+), 2 deletions(-)</code>
<code class="go"> delete mode 100644 bak/test.txt</code>
<code class="go"> create mode 100644 repo.rb</code>
<code class="go"> rewrite test.txt (100%)</code></pre>

<p>如果你查看生成的树对象，可以看到 repo.rb 文件对应的数据对象的 SHA-1 值：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git cat-file -p master^<code class="o">{</code>tree<code class="o">}</code>
<code class="go">100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt</code>
<code class="go">100644 blob 033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5      repo.rb</code>
<code class="go">100644 blob e3f094f522629ae358806b17daf78246c27c007b      test.txt</code></pre>

<p>接下来你可以使用 <code>git cat-file</code> 命令查看这个对象有多大：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git cat-file -s 033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5
<code class="go">22044</code></pre>

<p>现在，稍微修改这个文件，然后看看会发生什么：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> <code class="nb">echo</code> <code class="s1">'# testing'</code> <code class="p">&amp;</code>gt<code class="p">;&amp;</code>gt<code class="p">;</code> repo.rb
<code class="gp">$</code> git commit -am <code class="s1">'modified repo a bit'</code>
<code class="go">[master 2431da6] modified repo.rb a bit</code>
<code class="go"> 1 file changed, 1 insertion(+)</code></pre>

<p>查看这个提交生成的树对象，你会看到一些有趣的东西：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git cat-file -p master^<code class="o">{</code>tree<code class="o">}</code>
<code class="go">100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt</code>
<code class="go">100644 blob b042a60ef7dff760008df33cee372b945b6e884e      repo.rb</code>
<code class="go">100644 blob e3f094f522629ae358806b17daf78246c27c007b      test.txt</code></pre>

<p>repo.rb 对应一个与之前完全不同的数据对象，这意味着，虽然你只是在一个 400 行的文件后面加入一行新内容，Git 也会用一个全新的对象来存储新的文件内容：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git cat-file -s b042a60ef7dff760008df33cee372b945b6e884e
<code class="go">22054</code></pre>

<p>你的磁盘上现在有两个几乎完全相同、大小均为 22K 的对象。
如果 Git 只完整保存其中一个，再保存另一个对象与之前版本的差异内容，岂不更好？</p>

<p>事实上 Git 可以那样做。
Git 最初向磁盘中存储对象时所使用的格式被称为“松散（loose）”对象格式。
但是，Git 会时不时地将多个这些对象打包成一个称为“包文件（packfile）”的二进制文件，以节省空间和提高效率。
当版本库中有太多的松散对象，或者你手动执行 <code>git gc</code> 命令，或者你向远程服务器执行推送时，Git 都会这样做。
要看到打包过程，你可以手动执行 <code>git gc</code> 命令让 Git 对对象进行打包：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git gc
<code class="go">Counting objects: 18, done.</code>
<code class="go">Delta compression using up to 8 threads.</code>
<code class="go">Compressing objects: 100% (14/14), done.</code>
<code class="go">Writing objects: 100% (18/18), done.</code>
<code class="go">Total 18 (delta 3), reused 0 (delta 0)</code></pre>

<p>这个时候再查看 objects 目录，你会发现大部分的对象都不见了，与此同时出现了一对新文件：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> find .git/objects -type f
<code class="go">.git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37</code>
<code class="go">.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</code>
<code class="go">.git/objects/info/packs</code>
<code class="go">.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.idx</code>
<code class="go">.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.pack</code></pre>

<p>仍保留着的几个对象是未被任何提交记录引用的数据对象——在此例中是你之前创建的“what is up, doc?”和“test content”这两个示例数据对象。
因为你从没将它们添加至任何提交记录中，所以 Git 认为它们是摇摆（dangling）的，不会将它们打包进新生成的包文件中。</p>

<p>剩下的文件是新创建的包文件和一个索引。
包文件包含了刚才从文件系统中移除的所有对象的内容。
索引文件包含了包文件的偏移信息，我们通过索引文件就可以快速定位任意一个指定对象。
有意思的是运行 <code>gc</code> 命令前磁盘上的对象大小约为 22K，而这个新生成的包文件大小仅有 7K。
通过打包对象减少了 ⅔ 的磁盘占用空间。</p>

<p>Git 是如何做到这点的？
Git 打包对象时，会查找命名及大小相近的文件，并只保存文件不同版本之间的差异内容。
你可以查看包文件，观察它是如何节省空间的。
<code>git verify-pack</code> 这个底层命令可以让你查看已打包的内容：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git verify-pack -v .git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.idx
<code class="go">2431da676938450a4d72e260db3bf7b0f587bbc1 commit 223 155 12</code>
<code class="go">69bcdaff5328278ab1c0812ce0e07fa7d26a96d7 commit 214 152 167</code>
<code class="go">80d02664cb23ed55b226516648c7ad5d0a3deb90 commit 214 145 319</code>
<code class="go">43168a18b7613d1281e5560855a83eb8fde3d687 commit 213 146 464</code>
<code class="go">092917823486a802e94d727c820a9024e14a1fc2 commit 214 146 610</code>
<code class="go">702470739ce72005e2edff522fde85d52a65df9b commit 165 118 756</code>
<code class="go">d368d0ac0678cbe6cce505be58126d3526706e54 tag    130 122 874</code>
<code class="go">fe879577cb8cffcdf25441725141e310dd7d239b tree   136 136 996</code>
<code class="go">d8329fc1cc938780ffdd9f94e0d364e0ea74f579 tree   36 46 1132</code>
<code class="go">deef2e1b793907545e50a2ea2ddb5ba6c58c4506 tree   136 136 1178</code>
<code class="go">d982c7cb2c2a972ee391a85da481fc1f9127a01d tree   6 17 1314 1 \</code>
<code class="go">  deef2e1b793907545e50a2ea2ddb5ba6c58c4506</code>
<code class="go">3c4e9cd789d88d8d89c1073707c3585e41b0e614 tree   8 19 1331 1 \</code>
<code class="go">  deef2e1b793907545e50a2ea2ddb5ba6c58c4506</code>
<code class="go">0155eb4229851634a0f03eb265b69f5a2d56f341 tree   71 76 1350</code>
<code class="go">83baae61804e65cc73a7201a7252750c76066a30 blob   10 19 1426</code>
<code class="go">fa49b077972391ad58037050f2a75f74e3671e92 blob   9 18 1445</code>
<code class="go">b042a60ef7dff760008df33cee372b945b6e884e blob   22054 5799 1463</code>
<code class="go">033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5 blob   9 20 7262 1 \</code>
<code class="go">  b042a60ef7dff760008df33cee372b945b6e884e</code>
<code class="go">1f7a7a472abf3dd9643fd615f6da379c4acb3e3a blob   10 19 7282</code>
<code class="go">non delta: 15 objects</code>
<code class="go">chain length = 1: 3 objects</code>
<code class="go">.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.pack: ok</code></pre>

<p>此处，<code>033b4</code> 这个数据对象（即 repo.rb 文件的第一个版本，如果你还记得的话）引用了数据对象 <code>b042a</code>，即该文件的第二个版本。
命令输出内容的第三列显示的是各个对象在包文件中的大小，可以看到 <code>b042a</code> 占用了 22K 空间，而 <code>033b4</code> 仅占用 9 字节。
同样有趣的地方在于，第二个版本完整保存了文件内容，而原始的版本反而是以差异方式保存的——这是因为大部分情况下需要快速访问文件的最新版本。</p>

<p>最妙之处是你可以随时重新打包。
Git 时常会自动对仓库进行重新打包以节省空间。当然你也可以随时手动执行 <code>git gc</code> 命令来这么做。</p>
</section>













<section data-type="sect1" id="_refspec">
<h1>引用规格</h1>

<p>纵观全书，我们已经使用过一些诸如远程分支到本地引用的简单映射方式，但这种映射可以更复杂。
假设你添加了这样一个远程版本库：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git remote add origin https://github.com/schacon/simplegit-progit</pre>

<p>上述命令会在你的 <code>.git/config</code> 文件中添加一个小节，并在其中指定远程版本库的名称（<code>origin</code>）、URL 和一个用于获取操作的引用规格（refspec）：</p>

<pre data-type="programlisting" data-code-language="ini"><code class="k">[remote "origin"]</code>
	<code class="na">url</code> <code class="o">=</code> <code class="s">https://github.com/schacon/simplegit-progit</code>
<code class="s">	fetch = +refs/heads/*:refs/remotes/origin/*</code></pre>

<p>引用规格的格式由一个可选的 <code>+</code> 号和紧随其后的 <code>&lt;src&gt;:&lt;dst&gt;</code> 组成，其中 <code>&lt;src&gt;</code> 是一个模式（pattern），代表远程版本库中的引用；<code>&lt;dst&gt;</code> 是那些远程引用在本地所对应的位置。
<code>+</code> 号告诉 Git 即使在不能快进的情况下也要（强制）更新引用。</p>

<p>默认情况下，引用规格由 <code>git remote add</code> 命令自动生成， Git 获取服务器中 <code>refs/heads/</code> 下面的所有引用，并将它写入到本地的 <code>refs/remotes/origin/</code> 中。
所以，如果服务器上有一个 <code>master</code> 分支，我们可以在本地通过下面这种方式来访问该分支上的提交记录：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git log origin/master
<code class="gp">$</code> git log remotes/origin/master
<code class="gp">$</code> git log refs/remotes/origin/master</pre>

<p>上面的三个命令作用相同，因为 Git 会把它们都扩展成 <code>refs/remotes/origin/master</code>。</p>

<p>如果想让 Git 每次只拉取远程的 <code>master</code> 分支，而不是所有分支，可以把（引用规格的）获取那一行修改为：</p>

<pre data-type="programlisting">fetch = +refs/heads/master:refs/remotes/origin/master</pre>

<p>这仅是针对该远程版本库的 <code>git fetch</code> 操作的默认引用规格。
如果有某些只希望被执行一次的操作，我们也可以在命令行指定引用规格。
若要将远程的 <code>master</code> 分支拉到本地的 <code>origin/mymaster</code> 分支，可以运行：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git fetch origin master:refs/remotes/origin/mymaster</pre>

<p>你也可以指定多个引用规格。
在命令行中，你可以按照如下的方式拉取多个分支：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git fetch origin master:refs/remotes/origin/mymaster <code class="se">\</code>
<code class="go">	 topic:refs/remotes/origin/topic</code>
<code class="go">From git@github.com:schacon/simplegit</code>
<code class="go"> ! [rejected]        master     -&amp;gt; origin/mymaster  (non fast forward)</code>
<code class="go"> * [new branch]      topic      -&amp;gt; origin/topic</code></pre>

<p>在这个例子中，对 <code>master</code> 分支的拉取操作被拒绝，因为它不是一个可以快进的引用。
我们可以通过在引用规格之前指定 <code>+</code> 号来覆盖该规则。</p>

<p>你也可以在配置文件中指定多个用于获取操作的引用规格。
如果想在每次获取时都包括 <code>master</code> 和 <code>experiment</code> 分支，添加如下两行：</p>

<pre data-type="programlisting" data-code-language="ini"><code class="k">[remote "origin"]</code>
	<code class="na">url</code> <code class="o">=</code> <code class="s">https://github.com/schacon/simplegit-progit</code>
<code class="s">	fetch = +refs/heads/master:refs/remotes/origin/master</code>
<code class="s">	fetch = +refs/heads/experiment:refs/remotes/origin/experiment</code></pre>

<p>我们不能在模式中使用部分通配符，所以像下面这样的引用规格是不合法的：</p>

<pre data-type="programlisting">fetch = +refs/heads/qa*:refs/remotes/origin/qa*</pre>

<p>但我们可以使用命名空间（或目录）来达到类似目的。
假设你有一个 QA 团队，他们推送了一系列分支，同时你只想要获取 <code>master</code> 和 QA 团队的所有分支而不关心其他任何分支，那么可以使用如下配置：</p>

<pre data-type="programlisting" data-code-language="ini"><code class="k">[remote "origin"]</code>
	<code class="na">url</code> <code class="o">=</code> <code class="s">https://github.com/schacon/simplegit-progit</code>
<code class="s">	fetch = +refs/heads/master:refs/remotes/origin/master</code>
<code class="s">	fetch = +refs/heads/qa/*:refs/remotes/origin/qa/*</code></pre>

<p>如果项目的工作流很复杂，有 QA 团队推送分支、开发人员推送分支、集成团队推送并且在远程分支上展开协作，你就可以像这样（在本地）为这些分支创建各自的命名空间，非常方便。</p>








<section data-type="sect2" id="_pushing_refspecs">
<h2>引用规格推送</h2>

<p>像上面这样从远程版本库获取已在命名空间中的引用当然很棒，但 QA 团队最初应该如何将他们的分支放入远程的 <code>qa/</code> 命名空间呢？
我们可以通过引用规格推送来完成这个任务。</p>

<p>如果 QA 团队想把他们的 <code>master</code> 分支推送到远程服务器的 <code>qa/master</code> 分支上，可以运行：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git push origin master:refs/heads/qa/master</pre>

<p>如果他们希望 Git 每次运行 <code>git push origin</code> 时都像上面这样推送，可以在他们的配置文件中添加一条 <code>push</code> 值：</p>

<pre data-type="programlisting" data-code-language="ini"><code class="k">[remote "origin"]</code>
	<code class="na">url</code> <code class="o">=</code> <code class="s">https://github.com/schacon/simplegit-progit</code>
<code class="s">	fetch = +refs/heads/*:refs/remotes/origin/*</code>
<code class="s">	push = refs/heads/master:refs/heads/qa/master</code></pre>

<p>正如刚才所指出的，这会让 <code>git push origin</code> 默认把本地 <code>master</code> 分支推送到远程 <code>qa/master</code> 分支。</p>
</section>













<section data-type="sect2" id="-7ztxclUe">
<h2>删除引用</h2>

<p>你还可以借助类似下面的命令通过引用规格从远程服务器上删除引用：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git push origin :topic</pre>

<p>因为引用规格（的格式）是 <code>&lt;src&gt;:&lt;dst&gt;</code>，所以上述命令把 <code>&lt;src&gt;</code> 留空，意味着把远程版本库的 <code>topic</code> 分支定义为空值，也就是删除它。</p>
</section>





</section>













<section data-type="sect1" id="-33tacA">
<h1>传输协议</h1>

<p>Git 可以通过两种主要的方式在版本库之间传输数据：“哑（dumb）”协议和“智能（smart）”协议。
本节将会带你快速浏览这两种协议的运作方式。</p>








<section data-type="sect2" id="-jWtZH1c3">
<h2>哑协议</h2>

<p>如果你正在架设一个基于 HTTP 协议的只读版本库，一般而言这种情况下使用的就是哑协议。
这个协议之所以被称为“哑”协议，是因为在传输过程中，服务端不需要有针对 Git 特有的代码；抓取过程是一系列 HTTP 的 <code>GET</code> 请求，这种情况下，客户端可以推断出服务端 Git 仓库的布局。</p>
<div data-type="note" id="id-aOU7HPHOcA"><h6>Note</h6>
<p>现在已经很少使用哑协议了。
使用哑协议的版本库很难保证安全性和私有化，所以大多数 Git 服务器宿主（包括云端和本地）都会拒绝使用它。
一般情况下都建议使用智能协议，我们会在后面进行介绍。</p>
</div>

<p>让我们通过 simplegit 版本库来看看 <code>http-fetch</code> 的过程：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git clone http://server/simplegit-progit.git</pre>

<p>它做的第一件事就是拉取 <code>info/refs</code> 文件。
这个文件是通过 <code>update-server-info</code> 命令生成的，这也解释了在使用HTTP传输时，必须把它设置为 <code>post-receive</code> 钩子的原因：</p>

<pre data-type="programlisting">=&gt; GET info/refs
ca82a6dff817ec66f44342007202690a93763949     refs/heads/master</pre>

<p>现在，你得到了一个远程引用和 SHA-1 值的列表。
接下来，你要确定 HEAD 引用是什么，这样你就知道在完成后应该被检出到工作目录的内容：</p>

<pre data-type="programlisting">=&gt; GET HEAD
ref: refs/heads/master</pre>

<p>这说明在完成抓取后，你需要检出 <code>master</code> 分支。
这时，你就可以开始遍历处理了。
因为你是从 <code>info/refs</code> 文件中所提到的 <code>ca82a6</code> 提交对象开始的，所以你的首要操作是获取它：</p>

<pre data-type="programlisting">=&gt; GET objects/ca/82a6dff817ec66f44342007202690a93763949
(179 bytes of binary data)</pre>

<p>你取回了一个对象——这是一个在服务端以松散格式保存的对象，是你通过使用静态 HTTP GET 请求获取的。
你可以使用 zlib 解压缩它，去除其头部，查看提交记录的内容：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git cat-file -p ca82a6dff817ec66f44342007202690a93763949
<code class="go">tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf</code>
<code class="go">parent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</code>
<code class="go">author Scott Chacon &amp;lt;schacon@gmail.com&amp;gt; 1205815931 -0700</code>
<code class="go">committer Scott Chacon &amp;lt;schacon@gmail.com&amp;gt; 1240030591 -0700</code>

<code class="go">changed the version number</code></pre>

<p>接下来，你还要再获取两个对象，一个是树对象 <code>cfda3b</code>，它包含有我们刚刚获取的提交对象所指向的内容，另一个是它的父提交 <code>085bb3</code>：</p>

<pre data-type="programlisting">=&gt; GET objects/08/5bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
(179 bytes of data)</pre>

<p>这样就取得了你的下一个提交对象。
再抓取树对象：</p>

<pre data-type="programlisting">=&gt; GET objects/cf/da3bf379e4f8dba8717dee55aab78aef7f4daf
(404 - Not Found)</pre>

<p>噢——看起来这个树对象在服务端并不以松散格式对象存在，所以你得到了一个 404 响应，代表在 HTTP 服务端没有找到该对象。
这有好几个可能的原因——这个对象可能在替代版本库里面，或者在包文件里面。
Git 会首先检查所有列出的替代版本库：</p>

<pre data-type="programlisting">=&gt; GET objects/info/http-alternates
(empty file)</pre>

<p>如果这返回了一个包含替代版本库 URL 的列表，那么 Git 就会去那些地址检查松散格式对象和文件——这是一种能让派生项目共享对象以节省磁盘的好方法。
然而，在这个例子中，没有列出可用的替代版本库。所以你所需要的对象肯定在某个包文件中。
要检查服务端有哪些可用的包文件，你需要获取 <code>objects/info/packs</code> 文件，这里面有一个包文件列表（它也是通过执行 <code>update-server-info</code> 所生成的）：</p>

<pre data-type="programlisting">=&gt; GET objects/info/packs
P pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack</pre>

<p>服务端只有一个包文件，所以你要的对象显然就在里面。但是你要先检查它的索引文件以确认。
即使服务端有多个包文件，这也是很有用的，因为这样你就可以知道你所需要的对象是在哪一个包文件里面：</p>

<pre data-type="programlisting">=&gt; GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.idx
(4k of binary data)</pre>

<p>现在你有这个包文件的索引，你可以查看你要的对象是否在里面——因为索引文件列出了这个包文件所包含的所有对象的 SHA-1 值，和该对象存在于包文件中的偏移量。
你的对象就在这里，接下来就是获取整个包文件：</p>

<pre data-type="programlisting">=&gt; GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack
(13k of binary data)</pre>

<p>现在你也有了你的树对象，你可以继续在提交记录上漫游。
它们全部都在这个你刚下载的包文件里面，所以你不用继续向服务端请求更多下载了。
Git 会将开始时下载的 HEAD 引用所指向的 <code>master</code> 分支检出到工作目录。</p>
</section>













<section data-type="sect2" id="-MRt6hEcG">
<h2>智能协议</h2>

<p>哑协议虽然很简单但效率略低，且它不能从客户端向服务端发送数据。
智能协议是更常用的传送数据的方法，但它需要在服务端运行一个进程，而这也是 Git 的智能之处——它可以读取本地数据，理解客户端有什么和需要什么，并为它生成合适的包文件。
总共有两组进程用于传输数据，它们分别负责上传和下载数据。</p>










<section data-type="sect3" id="-0RtoHOhecB">
<h3>上传数据</h3>

<p><a data-type="indexterm" data-primary="git commands" data-secondary="send-pack" id="id-lgclsdSxHahpcx"></a><a data-type="indexterm" data-primary="git commands" data-secondary="receive-pack" id="id-8McaSbSPHbhoc3"></a>
为了上传数据至远端，Git 使用 <code>send-pack</code> 和 <code>receive-pack</code> 进程。
运行在客户端上的 <code>send-pack</code> 进程连接到远端运行的 <code>receive-pack</code> 进程。</p>












<section data-type="sect4" id="ssh-WDtGHEHAhMcx">
<h4>SSH</h4>

<p>举例来说，在项目中使用命令 <code>git push origin master</code> 时, <code>origin</code> 是由基于 SSH 协议的 URL 所定义的。
Git 会运行 <code>send-pack</code> 进程，它会通过 SSH 连接你的服务器。
它会尝试通过 SSH 在服务端执行命令，就像这样：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> ssh -x git@server <code class="s2">"git-receive-pack 'simplegit-progit.git'"</code>
<code class="go">00a5ca82a6dff817ec66f4437202690a93763949 refs/heads/master report-status \</code>
<code class="go">	delete-refs side-band-64k quiet ofs-delta \</code>
<code class="go">	agent=git/2:2.1.1+github-607-gfba4028 delete-refs</code>
<code class="go">0000</code></pre>

<p><code>git-receive-pack</code> 命令会立即为它所拥有的每一个引用发送一行响应——在这个例子中，就只有 <code>master</code> 分支和它的 SHA-1 值。
第一行响应中也包含了一个服务端能力的列表（这里是 <code>report-status</code>、<code>delete-refs</code> 和一些其它的，包括客户端的识别码）。</p>

<p>每一行以一个四位的十六进制值开始，用于指明本行的长度。
你看到第一行以 005b 开始，这在十六进制中表示 91，意味着第一行有 91 字节。
下一行以 003e 起始，也就是 62，所以下面需要读取 62 字节。
再下一行是 0000，表示服务端已完成了发送引用列表过程。</p>

<p>现在它知道了服务端的状态，你的 <code>send-pack</code> 进程会判断哪些提交记录是它所拥有但服务端没有的。
<code>send-pack</code> 会告知 <code>receive-pack</code> 这次推送将会更新的各个引用。
举个例子，如果你正在更新 <code>master</code> 分支，并且增加 <code>experiment</code> 分支，这个 <code>send-pack</code> 的响应将会是像这样：</p>

<pre data-type="programlisting">0076ca82a6dff817ec66f44342007202690a93763949 15027957951b64cf874c3557a0f3547bd83b3ff6 \
	refs/heads/master report-status
006c0000000000000000000000000000000000000000 cdfdb42577e2506715f8cfeacdbabc092bf63e8d \
	refs/heads/experiment
0000</pre>

<p>Git 会为每一个将要更新的引用发送一行数据，包括该行长度，旧 SHA-1 值，新 SHA-1 值和将要更新的引用。
第一行也包括了客户端的能力。
这里的全为 <em>0</em> 的 SHA-1 值表示之前没有过这个引用——因为你正要添加新的 experiment 引用。
删除引用时，将会看到相反的情况：右边的 SHA-1 值全为 <em>0</em>。</p>

<p>接下来，客户端会发送一个包文件，它包含了所有服务端还没有的对象。
最后，服务端会以成功（或失败）响应：</p>

<pre data-type="programlisting">000eunpack ok</pre>
</section>













<section data-type="sect4" id="https-1Qt6hXHjhqcy">
<h4>HTTP(S)</h4>

<p>HTTPS 与 HTTP 相比较，除了在“握手”过程略有不同外，其他基本相似。
连接是从下面这个请求开始的：</p>

<pre data-type="programlisting">=&gt; GET http://server/simplegit-progit.git/info/refs?service=git-receive-pack
001f# service=git-receive-pack
00ab6c5f0e45abd7832bf23074a333f739977c9e8188 refs/heads/master report-status \
	delete-refs side-band-64k quiet ofs-delta \
	agent=git/2:2.1.1~vmg-bitmaps-bugaloo-608-g116744e
0000</pre>

<p>这完成了客户端和服务端的第一次数据交换。
接下来客户端发起另一个请求，这次是一个 <code>POST</code> 请求，这个请求中包含了 <code>git-upload-pack</code> 提供的数据。</p>

<pre data-type="programlisting">=&gt; POST http://server/simplegit-progit.git/git-receive-pack</pre>

<p>这个 <code>POST</code> 请求的内容是 <code>send-pack</code> 的输出和相应的包文件。
服务端在收到请求后相应地作出成功或失败的 HTTP 响应。</p>
</section>

</section>













<section data-type="sect3" id="-oEt7hmhwc6">
<h3>下载数据</h3>

<p><a data-type="indexterm" data-primary="git commands" data-secondary="fetch-pack" id="id-8McXsbS0hbhoc3"></a><a data-type="indexterm" data-primary="git commands" data-secondary="upload-pack" id="id-qBcoSQSBhjh6cQ"></a>
当你在下载数据时， <code>fetch-pack</code> 和 <code>upload-pack</code> 进程就起作用了。
客户端启动 <code>fetch-pack</code> 进程，连接至远端的 <code>upload-pack</code> 进程，以协商后续传输的数据。</p>












<section data-type="sect4" id="ssh-1QtnHqhjhqcy">
<h4>SSH</h4>

<p>如果你通过 SSH 使用抓取功能，<code>fetch-pack</code> 会像这样运行：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> ssh -x git@server <code class="s2">"git-upload-pack 'simplegit-progit.git'"</code></pre>

<p>在 <code>fetch-pack</code> 连接后，<code>upload-pack</code> 会返回类似下面的内容：</p>

<pre data-type="programlisting">00dfca82a6dff817ec66f44342007202690a93763949 HEAD multi_ack thin-pack \
	side-band side-band-64k ofs-delta shallow no-progress include-tag \
	multi_ack_detailed symref=HEAD:refs/heads/master \
	agent=git/2:2.1.1+github-607-gfba4028
003fe2409a098dc3e53539a9028a94b6224db9d6a6b6 refs/heads/master
0000</pre>

<p>这与 <code>receive-pack</code> 的响应很相似，但是这里所包含的能力是不同的。
而且它还包含 HEAD 引用所指向内容（<code>symref=HEAD:refs/heads/master</code>），这样如果客户端执行的是克隆，它就会知道要检出什么。</p>

<p>这时候，<code>fetch-pack</code> 进程查看它自己所拥有的对象，并响应 “want” 和它需要的对象的 SHA-1 值。
它还会发送“have”和所有它已拥有的对象的 SHA-1 值。
在列表的最后，它还会发送“done”以通知 <code>upload-pack</code> 进程可以开始发送它所需对象的包文件：</p>

<pre data-type="programlisting">003cwant ca82a6dff817ec66f44342007202690a93763949 ofs-delta
0032have 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
0009done
0000</pre>
</section>













<section data-type="sect4" id="https-PDt9h6hvhycz">
<h4>HTTP(S)</h4>

<p>抓取操作的握手需要两个 HTTP 请求。
第一个是向和哑协议中相同的端点发送 <code>GET</code> 请求：</p>

<pre data-type="programlisting">=&gt; GET $GIT_URL/info/refs?service=git-upload-pack
001e# service=git-upload-pack
00e7ca82a6dff817ec66f44342007202690a93763949 HEAD multi_ack thin-pack \
	side-band side-band-64k ofs-delta shallow no-progress include-tag \
	multi_ack_detailed no-done symref=HEAD:refs/heads/master \
	agent=git/2:2.1.1+github-607-gfba4028
003fca82a6dff817ec66f44342007202690a93763949 refs/heads/master
0000</pre>

<p>这和通过 SSH 使用 <code>git-upload-pack</code> 是非常相似的，但是第二个数据交换则是一个单独的请求：</p>

<pre data-type="programlisting">=&gt; POST $GIT_URL/git-upload-pack HTTP/1.0
0032want 0a53e9ddeaddad63ad106860237bbf53411d11a7
0032have 441b40d833fdfa93eb2908e52742248faf0ee993
0000</pre>

<p>这个输出格式还是和前面一样的。
这个请求的响应包含了所需要的包文件，并指明成功或失败。</p>
</section>

</section>



</section>













<section data-type="sect2" id="-mVt9Tec2">
<h2>协议总结</h2>

<p>这一章节是传输协议的一个概貌。
传输协议还有很多其它的特性，像是 <code>multi_ack</code> 或 <code>side-band</code>，但是这些内容已经超出了本书的范围。
我们希望能给你展示客户端和服务端之间的基本交互过程；如果你需要更多的相关知识，你可以参阅 Git 的源代码。</p>
</section>





</section>













<section data-type="sect1" id="-6mtXtv">
<h1>维护与数据恢复</h1>

<p>有的时候，你需要对仓库进行清理 - 使它的结构变得更紧凑，或是对导入的仓库进行清理，或是恢复丢失的内容。
这个小节将会介绍这些情况中的一部分。</p>








<section data-type="sect2" id="_git_gc">
<h2>维护</h2>

<p>Git 会不定时地自动运行一个叫做 “auto gc” 的命令。
大多数时候，这个命令并不会产生效果。
然而，如果有太多松散对象（不在包文件中的对象）或者太多包文件，Git 会运行一个完整的 <code>git gc</code> 命令。
“gc” 代表垃圾回收，这个命令会做以下事情：收集所有松散对象并将它们放置到包文件中，将多个包文件合并为一个大的包文件，移除与任何提交都不相关的陈旧对象。</p>

<p>可以像下面一样手动执行自动垃圾回收：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git gc --auto</pre>

<p>就像上面提到的，这个命令通常并不会产生效果。
大约需要 7000 个以上的松散对象或超过 50 个的包文件才能让 Git 启动一次真正的 gc 命令。
你可以通过修改 <code>gc.auto</code> 与 <code>gc.autopacklimit</code> 的设置来改动这些数值。</p>

<p><code>gc</code> 将会做的另一件事是打包你的引用到一个单独的文件。
假设你的仓库包含以下分支与标签：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> find .git/refs -type f
<code class="go">.git/refs/heads/experiment</code>
<code class="go">.git/refs/heads/master</code>
<code class="go">.git/refs/tags/v1.0</code>
<code class="go">.git/refs/tags/v1.1</code></pre>

<p>如果你执行了 <code>git gc</code> 命令，<code>refs</code> 目录中将不会再有这些文件。
为了保证效率 Git 会将它们移动到名为 <code>.git/packed-refs</code> 的文件中，就像这样：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> cat .git/packed-refs
<code class="gp">#</code> pack-refs with: peeled fully-peeled
<code class="go">cac0cab538b970a37ea1e769cbbde608743bc96d refs/heads/experiment</code>
<code class="go">ab1afef80fac8e34258ff41fc1b867c702daa24b refs/heads/master</code>
<code class="go">cac0cab538b970a37ea1e769cbbde608743bc96d refs/tags/v1.0</code>
<code class="go">9585191f37f7b0fb9444f35a9bf50de191beadc2 refs/tags/v1.1</code>
<code class="go">^1a410efbd13591db07496601ebc7a059dd55cfe9</code></pre>

<p>如果你更新了引用，Git 并不会修改这个文件，而是向 <code>refs/heads</code> 创建一个新的文件。
为了获得指定引用的正确 SHA-1 值，Git 会首先在 <code>refs</code> 目录中查找指定的引用，然后再到 <code>packed-refs</code> 文件中查找。
所以，如果你在 <code>refs</code> 目录中找不到一个引用，那么它或许在 <code>packed-refs</code> 文件中。</p>

<p>注意这个文件的最后一行，它会以 <code>^</code> 开头。
这个符号表示它上一行的标签是附注标签，那一行是附注标签指向的那个提交。</p>
</section>













<section data-type="sect2" id="_data_recovery">
<h2>数据恢复</h2>

<p>在你使用 Git 的时候，你可能会意外丢失一次提交。
通常这是因为你强制删除了正在工作的分支，但是最后却发现你还需要这个分支；亦或者硬重置了一个分支，放弃了你想要的提交。
如果这些事情已经发生，该如何找回你的提交呢？</p>

<p>下面的例子将硬重置你的测试仓库中的 master 分支到一个旧的提交，以此来恢复丢失的提交。
首先，让我们看看你的仓库现在在什么地方：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git log --pretty<code class="o">=</code>oneline
<code class="go">ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit</code>
<code class="go">484a59275031909e19aadb7c92262719cfcdf19a added repo.rb</code>
<code class="go">1a410efbd13591db07496601ebc7a059dd55cfe9 third commit</code>
<code class="go">cac0cab538b970a37ea1e769cbbde608743bc96d second commit</code>
<code class="go">fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre>

<p>现在，我们将 <code>master</code> 分支硬重置到第三次提交：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git reset --hard 1a410efbd13591db07496601ebc7a059dd55cfe9
<code class="go">HEAD is now at 1a410ef third commit</code>
<code class="gp">$</code> git log --pretty<code class="o">=</code>oneline
<code class="go">1a410efbd13591db07496601ebc7a059dd55cfe9 third commit</code>
<code class="go">cac0cab538b970a37ea1e769cbbde608743bc96d second commit</code>
<code class="go">fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre>

<p>现在顶部的两个提交已经丢失了 - 没有分支指向这些提交。
你需要找出最后一次提交的 SHA-1 然后增加一个指向它的分支。
窍门就是找到最后一次的提交的 SHA-1 - 但是估计你记不起来了，对吗？</p>

<p>最方便，也是最常用的方法，是使用一个名叫 <code>git reflog</code> 的工具。
当你正在工作时，Git 会默默地记录每一次你改变 HEAD 时它的值。
每一次你提交或改变分支，引用日志都会被更新。
引用日志（reflog）也可以通过 <code>git update-ref</code> 命令更新，我们在 <a data-type="xref" href="#_git_refs">Git 引用</a> 有提到使用这个命令而不是是直接将 SHA-1 的值写入引用文件中的原因。
你可以在任何时候通过执行 <code>git reflog</code> 命令来了解你曾经做过什么：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git reflog
<code class="go">1a410ef HEAD@{0}: reset: moving to 1a410ef</code>
<code class="go">ab1afef HEAD@{1}: commit: modified repo.rb a bit</code>
<code class="go">484a592 HEAD@{2}: commit: added repo.rb</code></pre>

<p>这里可以看到我们已经检出的两次提交，然而并没有足够多的信息。
为了使显示的信息更加有用，我们可以执行 <code>git log -g</code>，这个命令会以标准日志的格式输出引用日志。</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git log -g
<code class="go">commit 1a410efbd13591db07496601ebc7a059dd55cfe9</code>
<code class="go">Reflog: HEAD@{0} (Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;)</code>
<code class="go">Reflog message: updating HEAD</code>
<code class="go">Author: Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;</code>
<code class="go">Date:   Fri May 22 18:22:37 2009 -0700</code>

<code class="go">		third commit</code>

<code class="go">commit ab1afef80fac8e34258ff41fc1b867c702daa24b</code>
<code class="go">Reflog: HEAD@{1} (Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;)</code>
<code class="go">Reflog message: updating HEAD</code>
<code class="go">Author: Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;</code>
<code class="go">Date:   Fri May 22 18:15:24 2009 -0700</code>

<code class="go">       modified repo.rb a bit</code></pre>

<p>看起来下面的那个就是你丢失的提交，你可以通过创建一个新的分支指向这个提交来恢复它。
例如，你可以创建一个名为 <code>recover-branch</code> 的分支指向这个提交（ab1afef）：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git branch recover-branch ab1afef
<code class="gp">$</code> git log --pretty<code class="o">=</code>oneline recover-branch
<code class="go">ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit</code>
<code class="go">484a59275031909e19aadb7c92262719cfcdf19a added repo.rb</code>
<code class="go">1a410efbd13591db07496601ebc7a059dd55cfe9 third commit</code>
<code class="go">cac0cab538b970a37ea1e769cbbde608743bc96d second commit</code>
<code class="go">fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre>

<p>不错，现在有一个名为 <code>recover-branch</code> 的分支是你的 <code>master</code> 分支曾经指向的地方，再一次使得前两次提交可到达了。
接下来，假设你丢失的提交因为某些原因不在引用日志中 - 我们可以通过移除 <code>recover-branch</code> 分支并删除引用日志来模拟这种情况。
现在前两次提交又不被任何分支指向了：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git branch -D recover-branch
<code class="gp">$</code> rm -Rf .git/logs/</pre>

<p>由于引用日志数据存放在 <code>.git/logs/</code> 目录中，现在你已经没有引用日志了。
这时该如何恢复那次提交？
一种方式是使用 <code>git fsck</code> 实用工具，将会检查数据库的完整性。
如果使用一个 <code>--full</code> 选项运行它，它会向你显示出所有没有被其他对象指向的对象：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git fsck --full
<code class="go">Checking object directories: 100% (256/256), done.</code>
<code class="go">Checking objects: 100% (18/18), done.</code>
<code class="go">dangling blob d670460b4b4aece5915caf5c68d12f560a9fe3e4</code>
<code class="go">dangling commit ab1afef80fac8e34258ff41fc1b867c702daa24b</code>
<code class="go">dangling tree aea790b9a58f6cf6f2804eeac9f0abbe9631e4c9</code>
<code class="go">dangling blob 7108f7ecb345ee9d0084193f147cdad4d2998293</code></pre>

<p>在这个例子中，你可以在 “dangling commit” 后看到你丢失的提交。
现在你可以用和之前相同的方法恢复这个提交，也就是添加一个指向这个提交的分支。</p>
</section>













<section data-type="sect2" id="_removing_objects">
<h2>移除对象</h2>

<p>Git 有很多很棒的功能，但是其中一个特性会导致问题，<code>git clone</code> 会下载整个项目的历史，包括每一个文件的每一个版本。
如果所有的东西都是源代码那么这很好，因为 Git 被高度优化来有效地存储这种数据。
然而，如果某个人在之前向项目添加了一个大小特别大的文件，即使你将这个文件从项目中移除了，每次克隆还是都要强制的下载这个大文件。
之所以会产生这个问题，是因为这个文件在历史中是存在的，它会永远在那里。</p>

<p>当你迁移 Subversion 或 Perforce 仓库到 Git 的时候，这会是一个严重的问题。
因为这些版本控制系统并不下载所有的历史文件，所以这种文件所带来的问题比较少。
如果你从其他的版本控制系统迁移到 Git 时发现仓库比预期的大得多，那么你就需要找到并移除这些大文件。</p>

<p><strong>警告：这个操作对提交历史的修改是破坏性的。</strong>
它会从你必须修改或移除一个大文件引用最早的树对象开始重写每一次提交。
如果你在导入仓库后，在任何人开始基于这些提交工作前执行这个操作，那么将不会有任何问题 - 否则，你必须通知所有的贡献者他们需要将他们的成果变基到你的新提交上。</p>

<p>为了演示，我们将添加一个大文件到测试仓库中，并在下一次提交中删除它，现在我们需要找到它，并将它从仓库中永久删除。
首先，添加一个大文件到仓库中：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> curl https://www.kernel.org/pub/software/scm/git/git-2.1.0.tar.gz <code class="p">&amp;</code>gt<code class="p">;</code> git.tgz
<code class="gp">$</code> git add git.tgz
<code class="gp">$</code> git commit -m <code class="s1">'add git tarball'</code>
<code class="go">[master 7b30847] add git tarball</code>
<code class="go"> 1 file changed, 0 insertions(+), 0 deletions(-)</code>
<code class="go"> create mode 100644 git.tgz</code></pre>

<p>哎呀 - 其实这个项目并不需要这个巨大的压缩文件。
现在我们将它移除：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git rm git.tgz
<code class="go">rm 'git.tgz'</code>
<code class="gp">$</code> git commit -m <code class="s1">'oops - removed large tarball'</code>
<code class="go">[master dadf725] oops - removed large tarball</code>
<code class="go"> 1 file changed, 0 insertions(+), 0 deletions(-)</code>
<code class="go"> delete mode 100644 git.tgz</code></pre>

<p>现在，我们执行 <code>gc</code> 来查看数据库占用了多少空间：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git gc
<code class="go">Counting objects: 17, done.</code>
<code class="go">Delta compression using up to 8 threads.</code>
<code class="go">Compressing objects: 100% (13/13), done.</code>
<code class="go">Writing objects: 100% (17/17), done.</code>
<code class="go">Total 17 (delta 1), reused 10 (delta 0)</code></pre>

<p>你也可以执行 <code>count-objects</code> 命令来快速的查看占用空间大小：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git count-objects -v
<code class="go">count: 7</code>
<code class="go">size: 32</code>
<code class="go">in-pack: 17</code>
<code class="go">packs: 1</code>
<code class="go">size-pack: 4868</code>
<code class="go">prune-packable: 0</code>
<code class="go">garbage: 0</code>
<code class="go">size-garbage: 0</code></pre>

<p><code>size-pack</code> 的数值指的是你的包文件以 KB 为单位计算的大小，所以你大约占用了 5MB 的空间。
在最后一次提交前，使用了不到 2KB - 显然，从之前的提交中移除文件并不能从历史中移除它。
每一次有人克隆这个仓库时，他们将必须克隆所有的 5MB 来获得这个微型项目，只因为你意外地添加了一个大文件。
现在来让我们彻底的移除这个文件。</p>

<p>首先你必须找到它。
在本例中，你已经知道是哪个文件了。
但是假设你不知道；该如何找出哪个文件或哪些文件占用了如此多的空间？
如果你执行 <code>git gc</code> 命令，所有的对象将被放入一个包文件中，你可以通过运行 <code>git verify-pack</code> 命令，然后对输出内容的第三列（即文件大小）进行排序，从而找出这个大文件。
你也可以将这个命令的执行结果通过管道传送给 <code>tail</code> 命令，因为你只需要找到列在最后的几个大对象。</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git verify-pack -v .git/objects/pack/pack-29…69.idx <code class="se">\</code>
<code class="go">  | sort -k 3 -n \</code>
<code class="go">  | tail -3</code>
<code class="go">dadf7258d699da2c8d89b09ef6670edb7d5f91b4 commit 229 159 12</code>
<code class="go">033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5 blob   22044 5792 4977696</code>
<code class="go">82c99a3e86bb1267b236a4b6eff7868d97489af1 blob   4975916 4976258 1438</code></pre>

<p>你可以看到这个大对象出现在返回结果的最底部：占用 5MB 空间。
为了找出具体是哪个文件，可以使用 <code>rev-list</code> 命令，我们在 <a data-type="xref" href="1-customizing-git.html#_enforcing_commit_message_format">指定特殊的提交信息格式</a> 中曾提到过。
如果你传递 <code>--objects</code> 参数给 <code>rev-list</code> 命令，它就会列出所有提交的 SHA-1、数据对象的 SHA-1 和与它们相关联的文件路径。
可以使用以下命令来找出你的数据对象的名字：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git rev-list --objects --all <code class="p">|</code> grep 82c99a3
<code class="go">82c99a3e86bb1267b236a4b6eff7868d97489af1 git.tgz</code></pre>

<p>现在，你只需要从过去所有的树中移除这个文件。
使用以下命令可以轻松地查看哪些提交对这个文件产生改动：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git log --oneline --branches -- git.tgz
<code class="go">dadf725 oops - removed large tarball</code>
<code class="go">7b30847 add git tarball</code></pre>

<p>现在，你必须重写 <code>7b30847</code> 提交之后的所有提交来从 Git 历史中完全移除这个文件。
为了执行这个操作，我们要使用 <code>filter-branch</code> 命令，这个命令在 <a data-type="xref" href="1-git-tools.html#_rewriting_history">重写历史</a> 中也使用过：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git filter-branch --index-filter <code class="se">\</code>
<code class="go">  'git rm --ignore-unmatch --cached git.tgz' -- 7b30847^..</code>
<code class="go">Rewrite 7b30847d080183a1ab7d18fb202473b3096e9f34 (1/2)rm 'git.tgz'</code>
<code class="go">Rewrite dadf7258d699da2c8d89b09ef6670edb7d5f91b4 (2/2)</code>
<code class="go">Ref 'refs/heads/master' was rewritten</code></pre>

<p><code>--index-filter</code> 选项类似于在 <a data-type="xref" href="1-git-tools.html#_rewriting_history">重写历史</a> 中提到的的 <code>--tree-filter</code> 选项，不过这个选项并不会让命令将修改在硬盘上检出的文件，而只是修改在暂存区或索引中的文件。</p>

<p>你必须使用 <code>git rm --cached</code> 命令来移除文件，而不是通过类似 <code>rm file</code> 的命令 - 因为你需要从索引中移除它，而不是磁盘中。
还有一个原因是速度 - Git 在运行过滤器时，并不会检出每个修订版本到磁盘中，所以这个过程会非常快。
如果愿意的话，你也可以通过 <code>--tree-filter</code> 选项来完成同样的任务。
<code>git rm</code> 命令的 <code>--ignore-unmatch</code> 选项告诉命令：如果尝试删除的模式不存在时，不提示错误。
最后，使用 <code>filter-branch</code> 选项来重写自 <code>7b30847</code> 提交以来的历史，也就是这个问题产生的地方。
否则，这个命令会从最旧的提交开始，这将会花费许多不必要的时间。</p>

<p>你的历史中将不再包含对那个文件的引用。
不过，你的引用日志和你在 <code>.git/refs/original</code> 通过 <code>filter-branch</code> 选项添加的新引用中还存有对这个文件的引用，所以你必须移除它们然后重新打包数据库。
在重新打包前需要移除任何包含指向那些旧提交的指针的文件：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> rm -Rf .git/refs/original
<code class="gp">$</code> rm -Rf .git/logs/
<code class="gp">$</code> git gc
<code class="go">Counting objects: 15, done.</code>
<code class="go">Delta compression using up to 8 threads.</code>
<code class="go">Compressing objects: 100% (11/11), done.</code>
<code class="go">Writing objects: 100% (15/15), done.</code>
<code class="go">Total 15 (delta 1), reused 12 (delta 0)</code></pre>

<p>让我们看看你省了多少空间。</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git count-objects -v
<code class="go">count: 11</code>
<code class="go">size: 4904</code>
<code class="go">in-pack: 15</code>
<code class="go">packs: 1</code>
<code class="go">size-pack: 8</code>
<code class="go">prune-packable: 0</code>
<code class="go">garbage: 0</code>
<code class="go">size-garbage: 0</code></pre>

<p>打包的仓库大小下降到了 8K，比 5MB 好很多。
可以从 size 的值看出，这个大文件还在你的松散对象中，并没有消失；但是它不会在推送或接下来的克隆中出现，这才是最重要的。
如果真的想要删除它，可以通过有 <code>--expire</code> 选项的 <code>git prune</code> 命令来完全地移除那个对象：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> git prune --expire now
<code class="gp">$</code> git count-objects -v
<code class="go">count: 0</code>
<code class="go">size: 0</code>
<code class="go">in-pack: 15</code>
<code class="go">packs: 1</code>
<code class="go">size-pack: 8</code>
<code class="go">prune-packable: 0</code>
<code class="go">garbage: 0</code>
<code class="go">size-garbage: 0</code></pre>
</section>





</section>













<section data-type="sect1" id="-jWtdFM">
<h1>环境变量</h1>

<p>Git 总是在一个 <code>bash</code> shell 中运行，并借助一些 shell 环境变量来决定它的运行方式。
有时候，知道它们是什么以及它们如何让 Git 按照你想要的方式去运行会很有用。
这里不会列出所有的 Git 环境变量，但我们会涉及最有的那部分。</p>








<section data-type="sect2" id="-mVtbHnF2">
<h2>全局行为</h2>

<p>像通常的程序一样，Git 的常规行为依赖于环境变量。</p>

<p><strong><code>GIT_EXEC_PATH</code></strong> 决定 Git 到哪找它的子程序 （像 <code>git-commit</code>, <code>git-diff</code> 等等）。
  你可以用 <code>git --exec-path</code> 来查看当前设置.</p>

<p>通常不会考虑修改 <strong><code>HOME</code></strong> 这个变量（太多其它东西都依赖它），这是 Git 查找全局配置文件的地方。
  如果你想要一个包括全局配置的真正的便携版 Git， 你可以在便携版 Git 的 shell 配置中覆盖 <code>HOME</code> 设置。</p>

<p><strong><code>PREFIX</code></strong> 也类似，除了用于系统级别的配置。
  Git 在 <code>$PREFIX/etc/gitconfig</code> 查找此文件.</p>

<p>如果设置了 <strong><code>GIT_CONFIG_NOSYSTEM</code></strong>，就禁用系统级别的配置文件。
  这在系统配置影响了你的命令，而你又无权限修改的时候很有用。</p>

<p><strong><code>GIT_PAGER</code></strong> 控制在命令行上显示多页输出的程序。
如果这个没有设置，就会用 <code>PAGER</code> .</p>

<p><strong><code>GIT_EDITOR</code></strong> 当用户需要编辑一些文本（比如提交信息）时， Git 会启动这个编辑器。
如果没设置，就会用 <code>EDITOR</code> 。</p>
</section>













<section data-type="sect2" id="-0Rtyh4Fa">
<h2>版本库位置</h2>

<p>Git 用了几个变量来确定它如何与当前版本库交互。</p>

<p><strong><code>GIT_DIR</code></strong> 是 <code>.git</code> 目录的位置.
如果这个没有设置， Git 会按照目录树逐层向上查找 <code>.git</code> 目录，直到到达 <code>~</code> 或 <code>/</code>。</p>

<p><strong><code>GIT_CEILING_DIRECTORIES</code></strong> 控制查找 <code>.git</code> 目录的行为。
如果你访问加载很慢的目录（如那些磁带机上的或通过网络连接访问的），你可能会想让 Git 早点停止尝试，尤其是 shell 构建时调用了 Git 。</p>

<p><strong><code>GIT_WORK_TREE</code></strong> 是非空版本库的工作目录的根路径
如果没指定，就使用 <code>$GIT_DIR</code> 的父目录。</p>

<p><strong><code>GIT_INDEX_FILE</code></strong> 是索引文件的路径（只有非空版本库有）</p>

<p><strong><code>GIT_OBJECT_DIRECTORY</code></strong> 用来指定 <code>.git/objects</code> 目录的位置。</p>

<p><strong><code>GIT_ALTERNATE_OBJECT_DIRECTORIES</code></strong> 一个冒号分割的列表 (格式类似 <code>/dir/one:/dir/two:…</code>) 用来告诉 Git 到哪里去找不在 <code>GIT_OBJECT_DIRECTORY</code> 目录中的对象.
如果你有很多项目有相同内容的大文件，这个可以用来避免存储过多备份。</p>
</section>













<section data-type="sect2" id="-oEtZT5FE">
<h2>路径规则</h2>

<p>所谓 “pathspec” 是指你在 Git 中如何指定路径， 包括通配符的使用。
它们会在 <code>.gitignore</code> 文件中用到，命令行里也会用到 （<code>git add *.c</code>）。</p>

<p><strong><code>GIT_GLOB_PATHSPECS</code> and <code>GIT_NOGLOB_PATHSPECS</code></strong> 控制通配符在路径规则中的默认行为。
如果 <code>GIT_GLOB_PATHSPECS</code> 设置为 1, 通配符表现为通配符（这是默认设置）; 如果 <code>GIT_NOGLOB_PATHSPECS</code> 设置为 1,通配符仅匹配字面。意思是 <code>*.c</code> 只会匹配 <em>文件名是</em> “*.c” 的文件， 而不是以 <code>.c</code> 结尾的文件。
你可以在各个路径规格中用 <code>:(glob)</code> 或 <code>:(literal)</code> 开头来覆盖这个配置，如 <code>:(glob)*.c</code> 。</p>

<p><strong><code>GIT_LITERAL_PATHSPECS</code></strong> 禁用上面的两种行为；通配符将不能用，前缀覆盖也不能用。</p>

<p><strong><code>GIT_ICASE_PATHSPECS</code></strong> 让所有的路径规格忽略大小写。</p>
</section>













<section data-type="sect2" id="-WDtmu5Fq">
<h2>提交</h2>

<p>Git 提交对象的创建通常最后是由 <code>git-commit-tree</code> 来完成， <code>git-commit-tree</code> 用这些环境变量作主要的信息源。 仅当这些值不存在才回退到预置的值。</p>

<p><strong><code>GIT_AUTHOR_NAME</code></strong> 是 “author” 字段的可读的名字。</p>

<p><strong><code>GIT_AUTHOR_EMAIL</code></strong> 是 “author” 字段的邮件。</p>

<p><strong><code>GIT_AUTHOR_DATE</code></strong> 是 “author” 字段的时间戳。</p>

<p><strong><code>GIT_COMMITTER_NAME</code></strong> 是 “committer” 字段的可读的名字。</p>

<p><strong><code>GIT_COMMITTER_EMAIL</code></strong> 是 “committer” 字段的邮件。</p>

<p><strong><code>GIT_COMMITTER_DATE</code></strong> 是 “committer” 字段的时间戳。</p>

<p>如果 <code>user.email</code> 没有配置， 就会用到 <strong><code>EMAIL</code></strong> 指定的邮件地址。
如果 <em>这个</em> 也没有设置， Git 继续回退使用系统用户和主机名。</p>
</section>













<section data-type="sect2" id="-1Qtvi5FR">
<h2>网络</h2>

<p>Git 使用 <code>curl</code> 库通过 HTTP来完成网络操作， 所以 <strong><code>GIT_CURL_VERBOSE</code></strong> 告诉 Git 显示所有由那个库产生的消息。
这跟在命令行执行 <code>curl -v</code> 差不多。</p>

<p><strong><code>GIT_SSL_NO_VERIFY</code></strong> 告诉 Git 不用验证 SSL 证书。
这在有些时候是需要的， 例如你用一个自己签名的证书通过 HTTPS 来提供 Git 服务， 或者你正在搭建 Git 服务器，还没有安装完全的证书。</p>

<p>如果 Git 操作在网速低于 <strong><code>GIT_HTTP_LOW_SPEED_LIMIT</code></strong> 字节／秒，并且持续 <strong><code>GIT_HTTP_LOW_SPEED_TIME</code></strong> 秒以上的时间，Git 会终止那个操作。
这些值会覆盖 <code>http.lowSpeedLimit</code> 和 <code>http.lowSpeedTime</code> 配置的值。</p>

<p><strong><code>GIT_HTTP_USER_AGENT</code></strong> 设置 Git 在通过 HTTP 通讯时用到的 user-agent。
默认值类似于 <code>git/2.0.0</code> 。</p>
</section>













<section data-type="sect2" id="-PDtYIlFG">
<h2>比较和合并</h2>

<p><strong><code>GIT_DIFF_OPTS</code></strong> 这个有点起错名字了
有效值仅支持 <code>-u&lt;n&gt;</code> 或 <code>--unified=&lt;n&gt;</code>，用来控制在 <code>git diff</code> 命令中显示的内容行数。</p>

<p><strong><code>GIT_EXTERNAL_DIFF</code></strong> 用来覆盖 <code>diff.external</code> 配置的值。
如果设置了这个值， 当执行Git <code>git diff</code> 时，Git 会调用该程序。</p>

<p><strong><code>GIT_DIFF_PATH_COUNTER</code></strong> 和 <strong><code>GIT_DIFF_PATH_TOTAL</code></strong> 对于 <code>GIT_EXTERNAL_DIFF</code> 或 <code>diff.external</code> 指定的程序有用。
前者表示在一系列文件中哪个是被比较的（从 1 开始），后者表示每批文件的总数。</p>

<p><strong><code>GIT_MERGE_VERBOSITY</code></strong> 控制递归合并策略的输出。
允许的值有下面这些：</p>

<ul>
<li>
<p>0 什么都不输出，除了可能会有一个错误信息。</p>
</li>
<li>
<p>1 只显示冲突。</p>
</li>
<li>
<p>2 还显示文件改变。</p>
</li>
<li>
<p>3 显示因为没有改变被跳过的文件。</p>
</li>
<li>
<p>4 显示处理的所有路径。</p>
</li>
<li>
<p>5 显示详细的调试信息。</p>
</li>
</ul>

<p>默认值是 2.</p>
</section>













<section data-type="sect2" id="-xwtEfDFB">
<h2>调试</h2>

<p>想 <em>真正地</em> 知道 Git 正在做什么?
Git 内置了相当完整的跟踪信息，你需要做的就是把它们打开。
这些变量的可以用的值如下：</p>

<ul>
<li>
<p>“true”, “1”, 或 “2” – 跟踪类别写到标准错误输出.</p>
</li>
<li>
<p>以 <code>/</code> 开头的绝对路径 – 跟踪输出会被写到那个文件。</p>
</li>
</ul>

<p><strong><code>GIT_TRACE</code></strong> 控制常规跟踪，它并不适用于特殊情况。
它跟踪的范围包括别名的展开和其他子程序的委托。</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> <code class="nv">GIT_TRACE</code><code class="o">=</code><code class="nb">true </code>git lga
<code class="go">20:12:49.877982 git.c:554               trace: exec: 'git-lga'</code>
<code class="go">20:12:49.878369 run-command.c:341       trace: run_command: 'git-lga'</code>
<code class="go">20:12:49.879529 git.c:282               trace: alias expansion: lga =&amp;gt; 'log' '--graph' '--pretty=oneline' '--abbrev-commit' '--decorate' '--all'</code>
<code class="go">20:12:49.879885 git.c:349               trace: built-in: git 'log' '--graph' '--pretty=oneline' '--abbrev-commit' '--decorate' '--all'</code>
<code class="go">20:12:49.899217 run-command.c:341       trace: run_command: 'less'</code>
<code class="go">20:12:49.899675 run-command.c:192       trace: exec: 'less'</code></pre>

<p><strong><code>GIT_TRACE_PACK_ACCESS</code></strong> 控制访问打包文件的跟踪信息
第一个字段是被访问的打包文件，第二个是文件的偏移量：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> <code class="nv">GIT_TRACE_PACK_ACCESS</code><code class="o">=</code><code class="nb">true </code>git status
<code class="go">20:10:12.081397 sha1_file.c:2088        .git/objects/pack/pack-c3fa...291e.pack 12</code>
<code class="go">20:10:12.081886 sha1_file.c:2088        .git/objects/pack/pack-c3fa...291e.pack 34662</code>
<code class="go">20:10:12.082115 sha1_file.c:2088        .git/objects/pack/pack-c3fa...291e.pack 35175</code>
<code class="gp">#</code> <code class="o">[</code>…<code class="o">]</code>
<code class="go">20:10:12.087398 sha1_file.c:2088        .git/objects/pack/pack-e80e...e3d2.pack 56914983</code>
<code class="go">20:10:12.087419 sha1_file.c:2088        .git/objects/pack/pack-e80e...e3d2.pack 14303666</code>
<code class="go">On branch master</code>
<code class="go">Your branch is up-to-date with 'origin/master'.</code>
<code class="go">nothing to commit, working directory clean</code></pre>

<p><strong><code>GIT_TRACE_PACKET</code></strong> 打开网络操作包级别的跟踪信息</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> <code class="nv">GIT_TRACE_PACKET</code><code class="o">=</code><code class="nb">true </code>git ls-remote origin
<code class="go">20:15:14.867043 pkt-line.c:46           packet:          git&amp;lt; # service=git-upload-pack</code>
<code class="go">20:15:14.867071 pkt-line.c:46           packet:          git&amp;lt; 0000</code>
<code class="go">20:15:14.867079 pkt-line.c:46           packet:          git&amp;lt; 97b8860c071898d9e162678ea1035a8ced2f8b1f HEAD\0multi_ack thin-pack side-band side-band-64k ofs-delta shallow no-progress include-tag multi_ack_detailed no-done symref=HEAD:refs/heads/master agent=git/2.0.4</code>
<code class="go">20:15:14.867088 pkt-line.c:46           packet:          git&amp;lt; 0f20ae29889d61f2e93ae00fd34f1cdb53285702 refs/heads/ab/add-interactive-show-diff-func-name</code>
<code class="go">20:15:14.867094 pkt-line.c:46           packet:          git&amp;lt; 36dc827bc9d17f80ed4f326de21247a5d1341fbc refs/heads/ah/doc-gitk-config</code>
<code class="gp">#</code> <code class="o">[</code>…<code class="o">]</code></pre>

<p><strong><code>GIT_TRACE_PERFORMANCE</code></strong> 控制性能数据的日志打印。
输出显示了每个 Git 命令调用花费的时间。</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> <code class="nv">GIT_TRACE_PERFORMANCE</code><code class="o">=</code><code class="nb">true </code>git gc
<code class="go">20:18:19.499676 trace.c:414             performance: 0.374835000 s: git command: 'git' 'pack-refs' '--all' '--prune'</code>
<code class="go">20:18:19.845585 trace.c:414             performance: 0.343020000 s: git command: 'git' 'reflog' 'expire' '--all'</code>
<code class="go">Counting objects: 170994, done.</code>
<code class="go">Delta compression using up to 8 threads.</code>
<code class="go">Compressing objects: 100% (43413/43413), done.</code>
<code class="go">Writing objects: 100% (170994/170994), done.</code>
<code class="go">Total 170994 (delta 126176), reused 170524 (delta 125706)</code>
<code class="go">20:18:23.567927 trace.c:414             performance: 3.715349000 s: git command: 'git' 'pack-objects' '--keep-true-parents' '--honor-pack-keep' '--non-empty' '--all' '--reflog' '--unpack-unreachable=2.weeks.ago' '--local' '--delta-base-offset' '.git/objects/pack/.tmp-49190-pack'</code>
<code class="go">20:18:23.584728 trace.c:414             performance: 0.000910000 s: git command: 'git' 'prune-packed'</code>
<code class="go">20:18:23.605218 trace.c:414             performance: 0.017972000 s: git command: 'git' 'update-server-info'</code>
<code class="go">20:18:23.606342 trace.c:414             performance: 3.756312000 s: git command: 'git' 'repack' '-d' '-l' '-A' '--unpack-unreachable=2.weeks.ago'</code>
<code class="go">Checking connectivity: 170994, done.</code>
<code class="go">20:18:25.225424 trace.c:414             performance: 1.616423000 s: git command: 'git' 'prune' '--expire' '2.weeks.ago'</code>
<code class="go">20:18:25.232403 trace.c:414             performance: 0.001051000 s: git command: 'git' 'rerere' 'gc'</code>
<code class="go">20:18:25.233159 trace.c:414             performance: 6.112217000 s: git command: 'git' 'gc'</code></pre>

<p><strong><code>GIT_TRACE_SETUP</code></strong> 显示 Git 发现的关于版本库和交互环境的信息</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> <code class="nv">GIT_TRACE_SETUP</code><code class="o">=</code><code class="nb">true </code>git status
<code class="go">20:19:47.086765 trace.c:315             setup: git_dir: .git</code>
<code class="go">20:19:47.087184 trace.c:316             setup: worktree: /Users/ben/src/git</code>
<code class="go">20:19:47.087191 trace.c:317             setup: cwd: /Users/ben/src/git</code>
<code class="go">20:19:47.087194 trace.c:318             setup: prefix: (null)</code>
<code class="go">On branch master</code>
<code class="go">Your branch is up-to-date with 'origin/master'.</code>
<code class="go">nothing to commit, working directory clean</code></pre>
</section>













<section data-type="sect2" id="-4gtZUaFv">
<h2>其它</h2>

<p>如果指定了 <strong><code>GIT_SSH</code></strong>， Git 连接 SSH 主机时会用指定的程序代替 <code>ssh</code> 。
它会被用 <code>$GIT_SSH [username@]host [-p &lt;port&gt;] &lt;command&gt;</code> 的命令方式调用。
这不是配置定制 <code>ssh</code> 调用方式的最简单的方法; 它不支持额外的命令行参数， 所以你必须写一个封装脚本然后让 <code>GIT_SSH</code> 指向它。
可能用 <code>~/.ssh/config</code> 会更简单。</p>

<p><strong><code>GIT_ASKPASS</code></strong> 覆盖了 <code>core.askpass</code> 配置。
这是 Git 需要向用户请求验证时用到的程序，它接受一个文本提示作为命令行参数，并在 <code>stdout</code> 中返回应答。
(查看 <a data-type="xref" href="1-git-tools.html#_credential_caching">凭证存储</a>_ 访问更多相关内容)</p>

<p><strong><code>GIT_NAMESPACE</code></strong> 控制有命令空间的引用的访问，与 <code>--namespace</code> 标志是相同的.
这主要在服务器端有用， 如果你想在一个版本库中存储单个版本库的多个 fork, 只要保持引用是隔离的就可以。</p>

<p><strong><code>GIT_FLUSH</code></strong> 强制 Git 在向标准输出增量写入时使用没有缓存的 I/O。
设置为 1 让 Git 刷新更多， 设置为 0 则使所有的输出被缓存。
默认值（若此变量未设置）是根据活动和输出模式的不同选择合适的缓存方案。</p>

<p><strong><code>GIT_REFLOG_ACTION</code></strong> 让你可以指定描述性的文字写到 reflog 中。
这有个例子：</p>

<pre data-type="programlisting" data-code-language="console"><code class="gp">$</code> <code class="nv">GIT_REFLOG_ACTION</code><code class="o">=</code><code class="s2">"my action"</code> git commit --allow-empty -m <code class="s1">'my message'</code>
<code class="go">[master 9e3d55a] my message</code>
<code class="gp">$</code> git reflog -1
<code class="go">9e3d55a HEAD@{0}: my action: my message</code></pre>
</section>





</section>













<section data-type="sect1" id="-MRtOC2">
<h1>总结</h1>

<p>现在，你应该相当了解 Git 在背后都做了些什么工作，并且在一定程度上也知道了 Git 是如何实现的。
本章讨论了很多底层命令，这些命令比我们在本书其余部分学到的高层命令来得更原始，也更简洁。
从底层了解 Git 的工作原理有助于更好地理解 Git 在内部是如何运作的，也方便你能够针对特定的工作流写出自己的工具和脚本。</p>

<p>作为一套内容寻址文件系统，Git 不仅仅是一个版本控制系统，它同时是一个非常强大且易用的工具。
我们希望你可以借助新学到的 Git 内部原理相关知识来实现出自己的应用，并且以更高级、更得心应手的方式来驾驭 Git。</p>
</section>







</section>









    <div class="navigation">
      <ul>
        <li><a href="1-git-other-environments.html" title="其它环境中的 Git">Next</a></li>
        <li><a href="1-git-and-other-scms.html" title="Git 与其他系统">Previous</a></li>
      </ul>
    </div>
  </body>
</html>
